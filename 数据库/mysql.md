# 一、数据库索引原理

## B+ Tree

### 1.数据结构

B树即平衡树，是一颗m路查找树，具有的关键性质如下：

每个结点至多m棵子树；

根结点字少有两颗子树，根结点至少有一个关键字；

除根结点外的每个分支结点至少有m/2棵子树；

叶子结点在同一层；

有k颗子树的分支结点存在k-1个关键字；

关键字数量满足┌m/2┐ - 1 <= j <= m - 1。

利用平衡树的优势，查询时间复杂度O(logN),加快了查询的速度。因为数据保存在叶子结点和非叶子结点中，用中序遍历B树的关键字。查找时二分查找。B树结构如图所示：

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091300383225.png)

B+树基于B树和叶子结点顺序访问指针实现，具有B树的平衡性，又可以通过指针提高查询性能。与B树不同之处在于，结点的关键字不存储数据，只起到索引作用，因此，m个关键字的结点，子节点有m个，关键字数量满足┌m/2┐ - 1 <= j <= m。。B+树的数据存储在叶子结点上，B树的数据存储在每个一结点。因此，B+树搜索过程与高度相同，保证了稳定性，同时横向指针保证可在叶子节点进行区间访问。查找时先在非叶子结点二分查找，再在叶子节点二分查找。插入删除操作会破坏平衡性，需要维护平衡树结构。B+树结构如图所示：

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091317678858.png)

### 2.与红黑树的比较

题目：为什么数据库系统和文件系统使用B+树作为索引结构，而不是其他平衡树，如红黑树？

- 更少的查找次数：

  平衡树的查找时间复杂度O（h），h为树的高度；红黑树的度为2，树的高度要比B+树大。

- 利用磁盘预读特性：

  每次磁盘I/O操作，会发生预读。预读过程中，磁盘顺序读取，不需要磁盘寻道。数据库利用磁盘预读原理，将一个结点大小设置为一个页大小，每个节点一次I/O可以载入，因此相邻结点能够被预读载入。同时，一个结点的最大度数（m路）取决于节点内key和data的大小，度数越大，深度越小，I/O次数越小。

## MySQL索引

### 1.什么是索引

索引是一种帮助MySQL高效获取数据的数据结构，在存储引擎层实现，不同存储引擎具有不同的索引类型和实现。

### 2. B+ Tree 索引

使用B+ Tree索引的关键是树的高度低，有序的数据存储位置接近，结合磁盘吮血读写，OS预读写特性，降低I/O次数。可以指定多个索引列，由多个索引列共同组成键。

### 3. InnoDB索引实现

当数据库一条记录包含多个字段，一棵B+树只能存储主键，如果搜索的是非主键，需要再建立第二套索引，这套索引由独立的B+树组织。有两种数据存储方式解决多个B+树访问同一个表的方法：聚簇索引与辅助索引。其中，InnoDB使用的是聚簇索引。

对于聚簇索引，行数据存储在主键B+树的叶子节点，辅助B+树索引数据和对应的主键。如下图所示，使用Name值搜索行数据，需要两个步骤：先在辅助B+树检索到相应地主键数据，再在主键B+树查找主键对应的叶子节点。

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091453469704.png)

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091503903957.png)

### 4.MyISM索引实现

MYISM使用非聚簇索引，非聚簇索引的两棵树结点结构完全一样，存储的关键字不同。行数据独立存储，两棵B+树的叶子节点存储指向行数据的指针。由于索引树的独立性，使用非主键索引搜索B+树无需访问主键的索引树。

### 5.两种索引存储方式的对比

因为聚簇索引要进行两次B+树的查找，似乎聚簇索引效率低于非聚簇索引，那么聚簇索引有哪些优缺点呢？

1.行数据存储在叶子节点，主键和行数据一起读入内存，找到叶子节点就可以立刻返回行数据，如上图按照id组织数据时，访问速度更快。同时可以充分利用磁盘的预读机制。

2.出现行移动或者数据页分裂时，使用主键值作为辅助B+树叶子节点无需更新叶子节点内容，即不管主键B+树结点如何变化，辅助索引树不受影响。

3.更新索引列代价高，会强制将每个被更新的行移动到新的位置。

4.聚簇索引可能会导致全表扫描。

# 二、查询性能优化

面试题：一条SQL语句执行得很慢的原因？

我们要分两种情况讨论：

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

## 1.大多数情况下很正常，偶尔很慢

此种情况共有两种原因。

第一种是最容易想到的，执行的语句别人在用并且加行锁，或者这条语句涉及的表，上了表锁。此时，使用 show processlist命令查看当前状态。如果上了锁，只能等待锁释放。

第二种情况是数据库正在刷新脏页。向数据库更新或者插入一条数据时，数据会在内存中更新，插入对应字段，但这些字段不会立刻持久化到磁盘，而是将更新记录写入redo log日志中，数据库空闲时，再进行同步。如果内存中的数据页和磁盘中的数据页不一致，内存中的数据页称为脏页。以下情景刷新脏页会导致SQL执行缓慢：

redo log写满了：数据库一直忙，redo log没机会刷新，很快写满了。此时，其他操作暂停，脏页flush到磁盘。此时，SQL语句会执行的很慢。

内存不够：查询的数据不在内存里，且剩余内存不足以存放查询数据时，需要淘汰部分数据页。如果是脏页，需要flush，这个过程需要等待。

## 2.SQL语句一直执行很慢

