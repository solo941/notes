# 一、数据库索引原理

## B+ Tree

### 1.数据结构

B树即平衡树，是一颗m路查找树，具有的关键性质如下：

每个结点至多m棵子树；

根结点字少有两颗子树，根结点至少有一个关键字；

除根结点外的每个分支结点至少有m/2棵子树；

叶子结点在同一层；

有k颗子树的分支结点存在k-1个关键字；

关键字数量满足┌m/2┐ - 1 <= j <= m - 1。

利用平衡树的优势，查询时间复杂度O(logN),加快了查询的速度。因为数据保存在叶子结点和非叶子结点中，用中序遍历B树的关键字。查找时二分查找。B树结构如图所示：

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091300383225.png)

B+树基于B树和叶子结点顺序访问指针实现，具有B树的平衡性，又可以通过指针提高查询性能。与B树不同之处在于，结点的关键字不存储数据，只起到索引作用，因此，m个关键字的结点，子节点有m个，关键字数量满足┌m/2┐ - 1 <= j <= m。。B+树的数据存储在叶子结点上，B树的数据存储在每个一结点。因此，B+树搜索过程与高度相同，保证了稳定性，同时横向指针保证可在叶子节点进行区间访问。查找时先在非叶子结点二分查找，再在叶子节点二分查找。插入删除操作会破坏平衡性，需要维护平衡树结构。B+树结构如图所示：

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091317678858.png)

### 2.与红黑树的比较

题目：为什么数据库系统和文件系统使用B+树作为索引结构，而不是其他平衡树，如红黑树？

- 更少的查找次数：

  平衡树的查找时间复杂度O（h），h为树的高度；红黑树的度为2，树的高度要比B+树大。

- 利用磁盘预读特性：

  每次磁盘I/O操作，会发生预读。预读过程中，磁盘顺序读取，不需要磁盘寻道。数据库利用磁盘预读原理，将一个结点大小设置为一个页大小，每个节点一次I/O可以载入，因此相邻结点能够被预读载入。同时，一个结点的最大度数（m路）取决于节点内key和data的大小，度数越大，深度越小，I/O次数越小。

## MySQL索引

### 1.什么是索引

索引是一种帮助MySQL高效获取数据的数据结构，在存储引擎层实现，不同存储引擎具有不同的索引类型和实现。

### 2. B+ Tree 索引

使用B+ Tree索引的关键是树的高度低，有序的数据存储位置接近，结合磁盘吮血读写，OS预读写特性，降低I/O次数。可以指定多个索引列，由多个索引列共同组成键。

### 3. InnoDB索引实现

当数据库一条记录包含多个字段，一棵B+树只能存储主键，如果搜索的是非主键，需要再建立第二套索引，这套索引由独立的B+树组织。有两种数据存储方式解决多个B+树访问同一个表的方法：聚簇索引与辅助索引。其中，InnoDB使用的是聚簇索引。

对于聚簇索引，行数据存储在主键B+树的叶子节点，辅助B+树索引数据和对应的主键。如下图所示，使用Name值搜索行数据，需要两个步骤：先在辅助B+树检索到相应地主键数据，再在主键B+树查找主键对应的叶子节点。

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091453469704.png)

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/20141027091503903957.png)

### 4.MyISM索引实现

MYISM使用非聚簇索引，非聚簇索引的两棵树结点结构完全一样，存储的关键字不同。行数据独立存储，两棵B+树的叶子节点存储指向行数据的指针。由于索引树的独立性，使用非主键索引搜索B+树无需访问主键的索引树。

### 5.两种索引存储方式的对比

因为聚簇索引要进行两次B+树的查找，似乎聚簇索引效率低于非聚簇索引，那么聚簇索引有哪些优缺点呢？

1.行数据存储在叶子节点，主键和行数据一起读入内存，找到叶子节点就可以立刻返回行数据，如上图按照id组织数据时，访问速度更快。同时可以充分利用磁盘的预读机制。

2.出现行移动或者数据页分裂时，使用主键值作为辅助B+树叶子节点无需更新叶子节点内容，即不管主键B+树结点如何变化，辅助索引树不受影响。

3.更新索引列代价高，会强制将每个被更新的行移动到新的位置。

4.聚簇索引可能会导致全表扫描。

# 二、查询性能优化

面试题：一条SQL语句执行得很慢的原因？

先写结论，我们要分两种情况讨论：

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

## 1.大多数情况下很正常，偶尔很慢

此种情况共有两种原因。

第一种是最容易想到的，执行的语句别人在用并且加行锁，或者这条语句涉及的表，上了表锁。此时，使用 **show processlist**命令查看当前状态。如果上了锁，只能等待锁释放。

第二种情况是数据库正在刷新脏页。向数据库更新或者插入一条数据时，数据会在内存中更新，插入对应字段，但这些字段不会立刻持久化到磁盘，而是将更新记录写入**redo log**日志中，数据库空闲时，再进行同步。如果内存中的数据页和磁盘中的数据页不一致，内存中的数据页称为脏页。以下情景刷新脏页会导致SQL执行缓慢：

redo log写满了：数据库一直忙，redo log没机会刷新，很快写满了。此时，其他操作暂停，脏页**flush**到磁盘。此时，SQL语句会执行的很慢。

内存不够：查询的数据不在内存里，且剩余内存不足以存放查询数据时，需要淘汰部分数据页。如果是脏页，需要flush，这个过程需要等待。

## 2.SQL语句一直执行很慢

自然会想到索引的问题，但也有分情况细分讨论：

```
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
```

我们先建立一个表，共有三列，主键id，c和d。

查询语句如下：

```
select * from t where 100 <c and c < 100000;
```

**第一种情况：此时，c列没有加索引，只能全表扫描。**

如果对c字段加索引，执行查询语句：

```
select * from t where c - 1 = 1000;
```

**第二种情况，查询字段进行了运算，查询时不会用上c的索引。**因为查询时的字段时c+1，此时，查询语句可以改成：

```
select * from t where c = 1000 + 1;
```

同理，字段的函数也不会执行索引。

现在来分析**第三种情况**，走索引未必比走全表扫描来的快。首先要厘清主键索引和非主键索引，主键索引存放的值是整行字段数据，非主键索引存放主键字段的值。非主键索引查询，要走两遍索引树。系统分析SQL语句并进行预测：走c索引的扫描行数少，还是全表扫描行数少。那么，系统是如何判断选择哪种扫描方式呢？

系统通过索引区分度来判断，如果一个索引上不同值越多，区分度越高。区分度越高，走索引查询优势越明显。判断区分度，系统是通过采样部分数据，预测索引的区分度。但如果采样的时候，刚好在数据集中的部分采用，**系统会错误判断全表的区分度，导致全表扫描。**

第三种情况可以使用以下方法挽救：

第一种方法是强制索引，假设c字段索引名为c_index，我们可通过下面语句强制执行索引:

```
select * from t force index(c_index) where c < 100 and c < 100000;
```

第二种方法，重新采样

```
show index from t;
analyze table t;
```

此外，在执行**联合索引查询**时，系统也会有可能选错索引。开发人员可以通过分析 Explain 结果来优化查询语句。

## 3.优化数据访问

第一种方法：减少请求的数据量

- 只返回必要的列：少使用select * 语句。
- 只返回必要的行，使用索引，使用LIMIT。
- 缓存重复查询的数据，避免在数据库中查询。

第二种方法：重构查询方式

- 切分大查询

```sql
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

- 分解大连接查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联。这样可以让缓存更高效，如果是大连接查询，其中一张表发生改变就会缓存失效；同时，单表查询的缓存结果可以被其他查询使用到。减少锁竞争，更容易对数据库进行拆分。

```sql
SELECT * FROM tab
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
```

```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

# 三、切分

随着业务数据量增多，亟需解决单库数据膨胀问题。

## 1.水平切分（Sharding)

将同一个表中记录拆分到多个结构相同的表中。可以将数据分布到集群的不同节点上，缓解单个服务器的压力。

Sharding策略：哈希取模，ID范围，映射表存储映射关系。

Sharding引起的问题：

- 事务：使用分布式事务（如XA接口）解决。
- 连接：将原来的连接分解成多个单表连接。
- ID唯一性：可使用全局唯一ID，或为每个分片指定ID范围，或者使用分布式ID生成器（Snowflake算法）。

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg)

## 2.垂直切分

垂直切分按照列的关系密集程度进行切分，可以将经常使用的列和不经常使用的列切分到不同表中。

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg)

# 四、存储引擎

## InnoDB

MySQL默认的事务性存储引擎，默认级别是可重复读。在可重复度隔离级别下，通过多版本并发控制（MVCC）和间隙锁（Gap Lock) 防止幻读。

主索引是聚簇索引，索引中保存数据，避免直接读取磁盘，提高查询性能。

支持在线热备份，其它存储引擎要获取一致性试图只能停止对所有表的写入。

## MyISAM

数据以紧密格式存储，适用于只读数据，较小的表。

提供了压缩表，空间数据索引等特性。

不支持事务，不支持行级锁。

读取时对读到的表加共享锁，写入时则加排它锁。上了共享锁的表可以并发插入。

可以手工或者自动执行检查和修复操作，但可能引起数据丢失，修复过程慢。

## 二者比较

- 事务：InnoDB是事务型。
- 并发：MyISAM只支持表级锁，InnoDB支持行级锁。
- 外键：InnoDB支持外键。
- 备份：InnoDB支持在线热备份。
- 容灾性：InnoDB支持事务恢复，MyISAM容灾性差

# 五、主从分离

## 主从复制

主服务器将数据更新写入Binary log中，由从服务器的I/O进程读取，并写入从服务器的Relay log中，最后由从服务器SQL进程读取Relay log,解析主服务器的数据更改并在从服务器中Replay。

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/master-slave.png)

## 读写分离

主服务器处理写操作和实时性高的读操作，从服务器处理读操作。

读写分离的优点：

- 缓解锁的争用
- 从服务器使用MyISAM，提升查询性能和开销；
- 增加冗余，提高可用性

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![pic](https://github.com/solo941/notes/blob/master/数据库/pics/master-slave-proxy.png)