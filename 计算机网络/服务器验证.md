# cookie,session,token

## Cookie

### 1.定义

HTTP 协议是无状态的，在购物网站处理事务时，需要一个标识区分用户。HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

### 2.用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### 3.过程

服务器发送响应报文中包含Set-Cookie首部字段，客户端将Cookie保存在浏览器中，在之后向同一服务器发送请求时，从浏览器取出Cookie信息并通过Cookie首部字段发送给服务器。

Cookie分为两类：

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）之后不再被缓存，服务器可以在Set-Cookie中设置。

除此之外，首部字段还可以设置HttpOnly,标记为HttpOnly的Cookie不能被JS脚本调用。**跨站脚本攻击(XSS)** 常常使用document.cookie访问，修改未经HttpOnly标记的Cookie,因此该标记可一定程度上避免XSS攻击。

标记为Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。

## Session

### 1.定义

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

### 2.过程

使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

### 3.Cookie 与 Session 的比较

Cookie与Session相辅相成：

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

# token

### 1.定义

上面所说的验证方式，程序通过服务器端存储的登陆信息来辨别请求，这种方式基于服务器的验证；随着移动互联网的兴起，这种验证方式的弊端越来越明显，主要表现在：

- 每个用户对应一个Session，当用户越来越多时，服务器开销不断增加。
- 可扩展性：使用负载均衡的集群，session的管理（复制的方案扩展性差，集中存储的方案单点故障问题）。
- 跨域资源共享（CORS）：移动端多台设备同时使用是，资源的共享问题。
- 跨站请求伪造（CSRF）：在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

为了解决这些问题，基于token (令牌) 的验证被提出并广泛使用。

### 2.验证过程

使用 Cookie 维护用户登录状态的过程如下：

![pic](https://github.com/solo941/notes/blob/master/计算机网络/pics/1350514-20180504123206667-444188772.png)

![pic](https://github.com/solo941/notes/blob/master/计算机网络/pics/1350514-20180504123326596-1492094512.png)

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户的 userID 通过特定的算法和密钥生成签名
- 服务器返回的响应报文中包含 userID 和签名组成的 token，客户端收到响应报文之后可以把 token 存储。
- 客户端之后每次向服务器请求资源需要验证时，需要携带 token作为参数。
- 服务器端通过密钥和算法重新计算新签名，并与 token 中签名比较，验证成功，返回请求的数据。

### 3.优势

- 无状态，可扩展。
- 安全性：请求中将token作为参数携带防止CSRF。
- 支持移动端访问
- 支持跨域访问
- 去耦合：token在任何地方都能生成，不需要绑定一个特定身份验证方案。



# 扫码登陆方案

### 服务器+网页端

过程：

- 用户进行登录时，向浏览器服务器发送获取登陆二维码的请求。
- 服务器收到请求随机生成一个uuid，将uuid作为key值存入redis服务器，同时设置过期时间；过期时间后，用户二维码需要刷新重新获取。
- 浏览器服务器将uuid与公司验证字符串，通过二维码生成接口生成二维码的图片，将二维码图片和uuid一起返回给用户浏览器。
- 浏览器每隔一秒向服务器发送请求，携带uuid作为当前页面标识符。

### 服务器+手机端

- 用户使用手机扫描浏览器的二维码，获取uuid和验证信息。由于手机端进行过登陆，在访问手机端服务器时，请求中会携带用户的token。
- 手机端服务器收到请求后，验证token，确定是否为合法用户的请求登陆。如果是，返回确认信息给手机端。
- 手机端将登陆确认框显示给用户，防止用户误操作。确认后，发送请求（携带 uuid 和 token），服务器解析其中的 userId 和 uuid，以 <uuid, userId> 键值对存储在redis。

### 登陆成功

手机端登陆成功后，浏览器再次发送请求时，浏览器服务器得到用户Id, 并调用登陆方法，生成浏览器端的token。响应报文中携带 token，登陆成功，token在浏览器端存储。

![pic](https://github.com/solo941/notes/blob/master/计算机网络/pics/1104082-20180819163724539-2009463073.png)



# 参考文献

1.[CyC2018](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md)

2.[彻底理解cookie，session，token](https://www.cnblogs.com/moyand/p/9047978.html)

3.[扫码登陆实现原理](https://www.cnblogs.com/liyasong/p/saoma.html)

