# HTTP

## 1.请求报文和响应报文

### 请求报文

![pic](https://github.com/solo941/notes/blob/master/计算机网络/pics/httprequest.png)

### 响应报文

![pic](https://github.com/solo941/notes/blob/master/计算机网络/pics/httpResponse.png)

### 请求方法

客户端发送的请求报文第一行为请求行，包含了方法字段。

#### GET

当前网络请求中，绝大部分使用的是 GET 方法。

#### HEAD

和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。

#### POST

POST 主要用来传输数据,下发报文使能接口，注册用户这些功能都是使用POST。

其它几种请求方法平时不太常用：**PUT**：上传文件，存在安全性问题，一般不使用该方法；**PATCH**：与PUT不同，可以部分修改原始资源；**DELETE**：与PUT相反，上传文件；**OPTIONS**：查询支持的方法；**CONNECT**：

在与代理服务器通信时建立隧道；**TRACE**：服务器会将通信路径返回给客户端，存在安全问题，一般不使用。

## 2.状态码

常见状态码：

100：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

200：OK；204：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。

301：永久性重定向；302：临时性重定向；303：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。

304 ：如果请求报文首部包含一些条件，如果不满足条件，则服务器会返回 304 状态码。

400 ：请求报文中存在语法错误；401 :发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败;403：请求被拒绝；404 ：Not Found

500 :服务器正在执行请求时发生错误；503:服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 3.缓存

### 定义

Http中具有缓存功能的是浏览器缓存和代理服务器缓存。当web请求到达缓存时，如果本地有已缓存的副本，可以从本地存储中提取内容。缓存具有缓解服务器压力，降低资源获取延迟的优势。

浏览器加载页面流程：

- 浏览器根据http头信息，确定是否命中强缓存，命中直接加载，否则请求发送到服务器。
- 服务器判断浏览器缓存是否失效，如果可以使用，服务器不返回资源，资源从浏览器加载。
- 否则，浏览器加载服务器资源，并更新缓存。

### Cache-Control

Http通过Cache-Control首部字段控制缓存

#### no-store

no-store 指令规定不能对请求或响应的任何一部分进行缓存。

#### no-cache

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

#### private

private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。

#### public

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。

#### max-age

max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。

### 其它常用首部字段

#### ETag 

资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

#### Last-Modified

用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。

#### Expires

用于告知缓存服务器该资源什么时候会过期。

####  Range

在请求报文中添加 Range 首部字段指定请求的范围。请求成功的话服务器返回的响应包含 206 Partial Content 状态码。

## HTTP/1.1 新特性

- 默认是长连接
- 支持流水线
- 支持同时打开多个 TCP 连接
- 支持虚拟主机：1台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。
- 新增状态码 100：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
- 支持分块传输编码：可以把数据分割成多块，让浏览器逐步显示页面。
- 新增缓存处理指令 max-age

#### 长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

#### 流水线

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

## HTTP/2.0 新特性

HTTP/2.0 的首要目标是通过完全的请求,响应多路复用,头部的压缩头部域来减小头部的体积,添加了请求优先级,服务端推送.为了支持这些特性,他需要大量的协议增加头部字段来支持,例如新的流量控制,差错处理,升级机制.而这些是每个web开发者都应该在他们的应用中用到的.

- 二进制分帧
- 首部压缩
- 流量控制
- 多路复用
- 请求优先级
- 服务器推送

###  二进制分帧

性能提升的核心在于二进制帧层.它指HTTP消息在客户端和服务端如何封装和传输.HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。一旦建立了HTTP / 2连接，客户端和服务器就通过交换帧来进行通信，这些帧用作协议内最小的通信单元。所有帧共享一个共同的9字节头，其中包含帧的长度，类型，标志位字段和31位流标识符。

基于二进制帧机制的消息传输机制特点：

- 所有的通信都建立在一个TCP连接上，可以传递大量的双向流通的流。
- 每个流都有独一无二的标志和优先级。
- 每个消息都是逻辑上的请求和响应消息。由一个或者多个帧组成。
- 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

这是 HTTP/2 协议提供高性能的基础。

### 请求和响应的多路复用

在HTTP/1.x中,用户想要多个并行的请求来提高性能,但是这样必须得使用多个TCP连接能实现并发和缩短延迟；在HTTP/2中,新的二进制帧层,解除了这个限制.使得所有的请求和响应多路复用.通过允许客户端和服务端把HTTP消息分解成独立的帧,交错传输,然后在另一端组装.

如图所示，在一次连接中的多个流.客户端传输数据帧到服务端(Stream5).服务端传输交错的帧序列(Stream1,Stream3)到客户端.此时,同时存在并行的3个流.

### 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送，HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了HTTP/1.X中头部阻塞的问题。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

### 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，而不需要客户端明确请求每一个资源！例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。HTTP / 2.0 脱离了严格的请求 - 响应语义，并支持一对多和服务器启动的推送工作流程。

每个推送的资源都是一个流，与内联资源不同，它允许客户端对其进行单独复用，优先化和处理。由浏览器执行的唯一安全限制是推送资源必须遵守同源策略：服务器必须对提供的内容具有权限。

### 流量控制

流量控制是一种机制,用来阻止发送者发送大量的接收者不需要,或者没能力处理的数据.接收者可能会在重负下很繁忙,或者只愿意分配固定的资源给特定的流.例如,客户端可能以高的优先级请求大量的视频数据,然后用户暂停了视频,那么客户端现在想要停止或者减少服务端的传输来避免取和缓存没必要的数据.

由于HTTP/2的那些流是在一个TCP的连接上.那么TCP连接不够细粒度,也没能提供应用级的API来控制单个流的传输.为了应对这种情况,HTTP/2提供了一系列的简单修筑块,来允许客户端和服务端实现他们自己的流级别的,连接级别的流量控制：

- 流量控制是有方向的.对于每个流和连接,每个接收者可以设置它想要窗口大小.

- 流量控制是基于信用的。每个接收者通告其初始连接和流量控制窗口（以字节为单位），只要发送者发送数据帧并通过接受者发送的WINDOW_UPDATE帧递增，该窗口就会减少。

- 流量控制不能禁用.当建立HTTP / 2连接时，客户端和服务器交换SETTINGS帧，这些帧设置双向流量控制窗口的大小。

- 流量控制是逐跳的,而不是端到端的.也就是说,一个中介可以使用它控制资源的使用,从而根据自己的标准和启发式实现资源分配机制.

  

