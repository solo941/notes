## 垃圾回收

垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

那么哪些内存是需要回收的呢？

## 判断对象是否可被回收

### 引用计数法

为对象分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。

缺点：无法解决循环引用的问题。

```Java
public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}
```

此时，a和b虽然已经置空，但存在相互引用，Test对象无法回收。

### 可达性分析算法

可达性算法是通过一个称为 `GC Roots` 的对象向下搜索，整个搜索路径就称为引用链，当一个对象到 `GC Roots` 没有任何引用链 `JVM` 就认为该对象是可以被回收的。

可作为 `GC Roots` 的对象包括以下4种：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

#### 虚拟机栈中局部变量表中引用的对象：

```Java
public class StackLocalParameter {
    public StackLocalParameter(String name){}
}

public static void testGC(){
    StackLocalParameter s = new StackLocalParameter("localParameter");
    s = null;
}
```

当s置空时，`localParameter` 对象也断掉了与 `GC Root` 的引用链，将被回收。

#### **方法区中类静态属性引用的对象**

```java
public class MethodAreaStaicProperties {
    public static MethodAreaStaicProperties m;
    public MethodAreaStaicProperties(String name){}
}

public static void testGC(){
    MethodAreaStaicProperties s = new MethodAreaStaicProperties("properties");
    s.m = new MethodAreaStaicProperties("parameter");
    s = null;
}
```

s是`GC Root`，s置空时，s 所指向的 properties 对象被回收；m是类的静态属性，也是`GC Root`，所以 parameter 对象不会被回收。

#### **方法区中常量引用的对象**

```java
public class MethodAreaStaicProperties {
    public static final MethodAreaStaicProperties m = MethodAreaStaicProperties("final");
    public MethodAreaStaicProperties(String name){}
}

public static void testGC(){
    MethodAreaStaicProperties s = new MethodAreaStaicProperties("staticProperties");
    s = null;
}
```

m是类的常量，是`GC Root`，所以 final 对象不会被回收。

#### **本地方法栈中引用的对象**

任何 Native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。

## 垃圾回收过程

### 标记-清除算法

标记清除算法分为两个步骤，标记和清除。 首先将需要回收的对象标记起来，然后再清除可回收对象。但是存在两个主要的问题:

- 标记和清除的效率都不高。
- 清除之后容易出现不连续内存，当需要分配一个较大内存时就不得不需要进行一次垃圾回收。

### 复制算法

复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。

现在的商业虚拟机都采用这种收集算法回收新生代。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

### 标记-整理算法

复制算法如果在存活对象较多时效率明显会降低，特别是在老年代中并没有多余的内存区域可以提供内存担保。所以老年代中使用的时候标记-整理算法，它的原理和标记-清除算法类似，只是最后一步的清除改为了将存活对象全部移动到一端，然后再将边界之外的内存全部回收。

## 堆内存模型

Java 堆（Java Heap）是`JVM`所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。

Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。

#### Eden区

大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 `Minor GC`，`Minor GC` 相比 `Major GC `更频繁，回收速度也更快。通过 `Minor GC` 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。

#### Survivor区

在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。设置两个 Survivor 区最大的好处就是解决标记-清除算法带来的内存碎片化问题。

#### 老年代

老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。以下三种对象会进入老年代：

1.经历16次 Minor GC 还能在新生代中存活的对象，会被送到老年代；

2.大对象；

3.如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年代。